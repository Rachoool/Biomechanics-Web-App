<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Model Viewer</title>
  <script src="../theme.js"></script>
  <script>
    (function () {
      const savedTheme = localStorage.getItem("theme") || "light";
      document.documentElement.setAttribute("data-theme", savedTheme);
    })();
  </script>
  <link rel="stylesheet" href="../css/upload_style.css">
  <style>

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .sidebar {
      background-color: transparent;
      color: var(--text-color);
      font-weight: bold;
      font-size: 1.5rem;
      margin: 20px 0 0 30px;
    }
    
    .main-container {
      display: flex;
      align-items: flex-start;
      margin: 20px;
      gap: 20px;
    }


    .viewer-wrapper {
      position: relative;
    }

    .viewer-container {
      width: 950px;
      height: 500px;
      border: 2px solid #ccc;
      background-color: white;
    }
    .landmark-list-container {
      width: 800px;
      background-color: var(--file-list-bg);
      color: var(--text-color);
      border: 2px solid var(--border-color);
      margin-top: 10px;
      font-size: 0.95rem;
    }
    .landmark-list-container h3 {
      margin: 5px 5px 10px 10px;
      font-size: 1.1rem;
    }
    #landmarkList {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #landmarkList li {
      border-bottom: 1px solid var(--border-color);
      padding: 6px 8px;
      word-break: break-word;
    }
    .control-buttons {
      position: absolute; 
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }


    .control-buttons button {
      padding: 10px 20px;
      font-size: 1rem;
      cursor: pointer;
    }

    .top-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .bottom-button {
      align-self: flex-end;
    }
    .file-list-container {
      width: 200px;
      height: 500px;
      overflow-y: auto;
      border: 2px solid #ccc;
      background-color: #fff;
      font-size: 0.95rem;
    }
    
    .file-list-container.collapsed {
      width: 0;
      padding: 0;
      border: none;
      overflow: hidden;
    }


    .file-list li.active {
      /* background-color: #00b8a9;  */
      color: #00b8a9; 
    }

    .model-filename.active {
      color: #00b8a9;
      font-weight: bold;
    }

 
    .viewer-container.expanded {
      width: calc(950px + 200px);
    }

    .file-list {
      list-style: none;
      padding: 10px;
      margin: 0;
    }

    .file-list li {
      padding: 6px 8px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .file-list li:hover {
      background-color: #f0f0f0;
    }
    :root {
      --bg-color: #fff;
      --text-color: #000;
      --sidebar-bg: #f9f9f9;
      --file-list-bg: #fff;
      --file-list-hover-bg: #f0f0f0;
      --border-color: #ccc;
    }

    [data-theme="dark"] {
      --bg-color: #121212;
      --text-color: #eee;
      --sidebar-bg: #121212;
      --file-list-bg: #2c2c2c;
      --file-list-hover-bg: #444444;
      --border-color: #555;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .file-list-container {
      background-color: var(--file-list-bg);
      border-color: var(--border-color);
      color: var(--text-color);
    }

    .file-list li {
      border-bottom: 1px solid var(--border-color);
      color: var(--text-color);
    }

    .file-list li:hover {
      background-color: var(--file-list-hover-bg);
    }

    .viewer-container {
      background-color: var(--file-list-bg);
      color: var(--text-color);
    }
    .filename-header {
      display: flex;
      align-items: center; /* ÂûÇÁõ¥Â±Ö‰∏≠ */
      gap: 10px;           /* ÊéßÂà∂ÊåâÈíÆÂíåÊñáÂ≠óÁöÑÈó¥Ë∑ù */
      padding: 10px;
    }
    .hamburger {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      margin-top: -1px;
    }

    .model-filename {
      font-weight: bold;
      font-size: 1rem;
      color: var(--text-color);
      position: absolute;
      left: 5%;
    }


  </style>

  <!-- ‚úÖ Three.js v0.146.0 with global OrbitControls support -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/STLLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/exporters/STLExporter.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/exporters/OBJExporter.js"></script>

</head>
<body>

<!-- Top navigation bar -->
<nav class="navbar">
  <div class="logo"><a href="index.html">BioData Viewer</a></div>
  <div class="nav-right">
    <ul>
      <li><a href="index.html" class="nav-button">Home</a></li>
    </ul>

    <!-- Theme Toggle Dropdown -->
    <div class="nav-button theme-toggle">
      <button class="theme-button" id="themeToggle">
        <span class="theme-icon" id="themeIcon">üåô</span>
        <span>Theme</span>
      </button>
      <div class="dropdown-menu" id="themeDropdown">
        <div class="dropdown-item active" data-theme="light">
          <span>‚òÄÔ∏è</span>
          <span>Light Mode</span>
        </div>
        <div class="dropdown-item" data-theme="dark">
          <span>üåô</span>
          <span>Dark Mode</span>
        </div>
      </div>
    </div>
  </div>
</nav>
<div class="sidebar">View</div>
<!-- Main section -->

<!-- hamburger button -->
  <!-- <button class="hamburger" id="hamburgerBtn">‚ò∞</button> -->
  <!-- <div id="modelFilename" class="model-filename">No model loaded</div> -->
  <div class="filename-header">
    <button class="hamburger" id="hamburgerBtn">‚ò∞</button>
    <div id="modelFilename" class="model-filename">No model loaded</div>
  </div>
  
  <div class="main-container">
    <div class="file-list-container" id="fileListContainer">
      <ul class="file-list" id="fileList">
       
        <li>test1.stl</li>
        <li>test2.obj</li>
        <li>long_filename_model_3.obj</li>
        
      </ul>
    </div>
  
    <div class="viewer-wrapper">
      <div class="viewer-container" id="viewerContainer">
        Loading...
      </div>
      <div class="landmark-list-container" id="landmarkListContainer">
        <h3>Landmarks</h3>
        <ul id="landmarkList"></ul>
      </div>
    </div>

  <div class="control-buttons">
    <div class="top-buttons">
      <!-- <button onclick="alert('Use mouse to rotate')">Rotate</button>
      <button onclick="alert('Scroll to zoom')">Zoom</button>
      <button onclick="alert('Right-click to pan')">Pan</button> -->
    </div>
    <div class="top-buttons">
      <button onclick="toggleLandmarkMode()" id="landmarkBtn">Enter Landmark Mode</button>
    </div>
    <div class="top-buttons">
      <button onclick="toggleDeleteMode()" id="deleteBtn">Enter Delete Mode</button>
    </div>


    <button class="bottom-button" onclick="exportOBJ()">Save as OBJ</button>
    <button class="bottom-button" onclick="exportSTL()">Save as STL</button>
    <button class="bottom-button" onclick="deleteCurrentModel()">Delete Current Model</button>

</div>

<!-- Overlay for closing dropdown -->
<div class="dropdown-overlay" id="dropdownOverlay"></div>

<script>
  let renderer, camera, scene, controls;
  let landmarkMode = false;
  let deleteMode = false;
  const landmarks = [];
  const landmarkData = new Map(); // Â≠òÂÇ® landmark ‰∏éÂêçÁß∞ÂèäÊñáÂ≠óSprite

  const mouse = new THREE.Vector2();
  const raycaster = new THREE.Raycaster();

  function getQueryParam(name) {
    const params = new URLSearchParams(window.location.search);
    return params.get(name);
  }

  async function loadModelList() {
    try {
      const res = await fetch("http://localhost:5000/api/models");
      const data = await res.json(); 

      const fileList = document.getElementById("fileList");
      fileList.innerHTML = "";

      data.models.forEach(file => {
        const li = document.createElement("li");
        li.textContent = file;
        li.onclick = () => loadModel(file);
        fileList.appendChild(li);
      });

      const initialFile = getQueryParam("file");
      if (initialFile && data.models.includes(initialFile)) {
        loadModel(initialFile);
      }

    } catch (err) {
      console.error("Failed to load models:", err);
    }
  }

  let currentFilename = null; 

  function loadModel(filename) {
    currentFilename = filename;
    document.getElementById("modelFilename").textContent = filename;
    const container = document.getElementById("viewerContainer");
    container.innerHTML = ""; 

    // loaded file name active status control
    modelFilenameDiv.classList.add('active');
    const lis = document.querySelectorAll("#fileList li");
    lis.forEach(li => li.classList.remove("active"));
    const selectedLi = Array.from(lis).find(li => li.textContent === filename);
    if (selectedLi) {
      selectedLi.classList.add("active");
    }

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, 800 / 500, 0.1, 1000);
    camera.position.set(0, 0, 100);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(800, 500);
    container.appendChild(renderer.domElement);

    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    scene.add(light);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    const ext = filename.split('.').pop().toLowerCase();
    const modelUrl = `http://localhost:5000/uploads/${filename}`;

    function centerAndRender(object) {
      scene.add(object);
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      object.position.sub(center);
      camera.position.set(0, 0, box.getSize(new THREE.Vector3()).length() * 1.2);
      controls.update();
      animate();

      renderer.domElement.addEventListener('click', (event) => {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
          const target = intersects[0].object;

          if (landmarkMode) {
            const point = intersects[0].point;
            addLandmarkAt(point);
          } else if (deleteMode && target.geometry?.type === "SphereGeometry") {
            scene.remove(target);

            // Âà†Èô§ÊñáÂ≠ó sprite
            const info = landmarkData.get(target);
            if (info){
              if (info.label){
                scene.remove(info.label);
              }

              const landmarkList = document.getElementById("landmarkList");
              const items = landmarkList.getElementsByTagName("li");
              for (let i = 0; i < items.length; i++) {
                if (items[i].textContent.startsWith(info.name + " ")) {
                  landmarkList.removeChild(items[i]);
                  break;
                }
              }
              landmarkData.delete(target);
            }
            renderer.render(scene, camera);
          }
        }
      });
    }

    if (ext === "stl") {
      const loader = new THREE.STLLoader();
      loader.load(modelUrl, geometry => {
        const material = new THREE.MeshStandardMaterial({ color: 0x0077be });
        const mesh = new THREE.Mesh(geometry, material);
        centerAndRender(mesh);
      }, undefined, error => {
        console.error(error);
        container.textContent = "Failed to load STL model.";
      });
    } else if (ext === "obj") {
      const loader = new THREE.OBJLoader();
      loader.load(modelUrl, object => {
        centerAndRender(object);
      }, undefined, error => {
        console.error(error);
        container.textContent = "Failed to load OBJ model.";
      });
    } else {
      container.textContent = "Unsupported file type.";
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
  }

  window.onload = loadModelList;


  document.getElementById("hamburgerBtn").addEventListener("click", () => {
    const fileListContainer = document.getElementById("fileListContainer");
    const viewer = document.getElementById("viewerContainer");

    fileListContainer.classList.toggle("collapsed");
    viewer.classList.toggle("expanded");
  });


  function toggleLandmarkMode() {
    landmarkMode = !landmarkMode;
    const btn = document.getElementById('landmarkBtn');
    btn.textContent = landmarkMode ? "Exit Landmark Mode" : "Enter Landmark Mode";
    btn.style.backgroundColor = landmarkMode ? "#ffa500" : ""; 
  }

  function toggleDeleteMode() {
    deleteMode = !deleteMode;
    const btn = document.getElementById('deleteBtn');
    btn.textContent = deleteMode ? "Exit Delete Mode" : "Enter Delete Mode";
    btn.style.backgroundColor = deleteMode ? "#ff5555" : "";

    if (deleteMode && landmarkMode) {
      toggleLandmarkMode(); 
    }
  }
  const landmarkInfoList = []; 

  function addLandmarkAt(position) {
    const name = prompt("Enter a name for this landmark:");
    if (!name) return;

    for (let existing of landmarkData.values()){
      if (existing.name === name){
        alert("Error: A landmark with this name already exists.");
        return;
      }
    }
    const sphereGeometry = new THREE.SphereGeometry(1.5, 16, 16);
    const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    const landmark = new THREE.Mesh(sphereGeometry, sphereMaterial);
    landmark.position.copy(position);
    scene.add(landmark);
    landmarks.push(landmark);

    const label = createTextLabel(name);
    label.position.copy(position); 
    scene.add(label);

    landmarkData.set(landmark, { name, label });
    landmarkInfoList.push(
      {
        name,
        position: position.clone()
      }
    );
    const landmarkList = document.getElementById("landmarkList");
    const li = document.createElement("li");
    li.textContent = `${name} (${position.x.toFixed(1)}, ${position.y.toFixed(1)}, ${position.z.toFixed(1)})`;
    landmarkList.appendChild(li);

    console.log("Landmark added:", name, position);
  }

  function createTextLabel(text) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = 'bold 48px Arial';
    ctx.fillStyle = 'rgba(255, 255, 0, 1)';  
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.needsUpdate = true;

    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, depthWrite: false });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(15, 7.5, 1);  // ÂèØ‰ª•ÈÄÇÂΩìË∞ÉÊï¥Â§ßÂ∞è

    return sprite;
}

  function exportSTL() {
    const filename = prompt("Enter filename (without extension):");
    if (!filename) return;

    const exporter = new THREE.STLExporter();
    const sceneToExport = new THREE.Scene();

    scene.children.forEach(obj => {
      if (obj.isMesh || obj.geometry?.type === "SphereGeometry") {
        sceneToExport.add(obj.clone());
      }
    });

    const result = exporter.parse(sceneToExport);
    const blob = new Blob([result], { type: 'text/plain' });
    const formData = new FormData();
    const fullFilename = filename + ".stl";
    formData.append('file', blob, fullFilename);

    fetch('http://localhost:5000/api/upload', {
      method: 'POST',
      body: formData
    })
      .then(res => res.json())
      .then(data => {
        if (data.status === 'success') {
          alert('STL file saved to server.');
          loadModelList(); 
        } else {
          alert('Failed to save STL file.');
        }
      })
      .catch(err => {
        console.error('Upload failed:', err);
        alert('Failed to upload STL file.');
      });
  }


  function exportOBJ() {
    const filename = prompt("Enter filename (without extension):");
    if (!filename) return;

    const exporter = new THREE.OBJExporter();
    const sceneToExport = new THREE.Scene();

    scene.children.forEach(obj => {
      if (obj.isMesh || obj.geometry?.type === "SphereGeometry") {
        sceneToExport.add(obj.clone());
      }
    });

    const result = exporter.parse(sceneToExport);
    const blob = new Blob([result], { type: 'text/plain' });
    const formData = new FormData();
    const fullFilename = filename + ".obj";
    formData.append('file', blob, fullFilename);

    fetch('http://localhost:5000/api/upload', {
      method: 'POST',
      body: formData
    })
      .then(res => res.json())
      .then(data => {
        if (data.status === 'success') {
          alert('OBJ file saved to server.');
          loadModelList(); 
        } else {
          alert('Failed to save OBJ file.');
        }
      })
      .catch(err => {
        console.error('Upload failed:', err);
        alert('Failed to upload OBJ file.');
      });
  }


  function deleteCurrentModel() {
    if (!currentFilename) {
      alert("No model is currently loaded.");
      return;
    }

    if (!confirm(`Are you sure you want to delete "${currentFilename}"?`)) return;

    fetch(`http://localhost:5000/api/delete/${currentFilename}`, {
      method: "DELETE"
    })
      .then(res => res.json())
      .then(data => {
        if (data.status === "success") {
          alert(`Model "${currentFilename}" deleted.`);
          currentFilename = null;
          const container = document.getElementById("viewerContainer");
          container.innerHTML = "No model loaded.";
          loadModelList();  
        } else {
          alert("Delete failed: " + data.message);
        }
      })
      .catch(err => {
        console.error("Delete request error:", err);
        alert("Request failed.");
      });
  }



</script>


</body>
</html>